---
title: "Лямбда-выражения"
description: "Сведения об использовании лямбда-выражений, являющихся блоками исполняемого кода, которые могут быть переданы в качестве аргументов."
keywords: ".NET, .NET Core, лямбда-выражения, лямбда, делегаты"
ms-author: ronpet
author: rpetrusha
ms.date: 11/22/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: b6a0539a-8ce5-4da7-adcf-44be345a2714
ms.translationtype: Human Translation
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: bbb524e50d74207227420d073afd5758d3d5aaa7
ms.contentlocale: ru-ru
ms.lasthandoff: 07/28/2017

---

# <a name="lambda-expressions"></a>Лямбда-выражения #

*Лямбда-выражение* представляет собой блок кода (выражение или блок оператора), который рассматривается как объект. Оно может передаваться в качестве аргумента в методы, а также возвращаться вызовами метода. Лямбда-выражения широко используются для:

- передачи выполняемого кода в асинхронные методы, такие как @System.Threading.Tasks.Task.Run(System.Action);

- написания [выражений запросов LINQ](linq/index.md);

- создания [деревьев выражений](expression-trees-building.md).

Лямбда-выражения — это код, который может быть представлен как делегат или дерево выражений, которое компилируется в делегат. Конкретный тип делегата лямбда-выражения зависит от его параметров и возвращаемого значения. Лямбда-выражения, которые не возвращают значение, соответствуют конкретному делегату `Action` в зависимости от числа параметров. Лямбда-выражения, которые возвращают значение, соответствуют конкретному делегату `Func` в зависимости от числа параметров. Например, лямбда-выражение, которое имеет два параметра, но не возвращает значение, соответствует делегату @System.Action%602. Лямбда-выражение, которое имеет один параметр и возвращает значение, соответствует делегату @System.Func%602.

Лямбда-выражение использует `=>`, [оператор объявления лямбда-выражения](language-reference/operators/lambda-operator.md), для отделения списка параметров лямбда-выражения от исполняемого кода. Чтобы создать лямбда-выражение, необходимо указать входные параметры (если они есть) с левой стороны лямбда-оператора, и поместить блок выражений или операторов с другой стороны. Например, однострочное лямбда-выражение `x => x * x` задает параметр с именем `x` и возвращает значение `x` в квадрате. Можно назначить это выражение типу делегата, как показано в следующем примере:

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/lambda1.cs#1)]

Можно также передать его непосредственно в качестве аргумента метода:

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/lambda2.cs#2)]

## <a name="expression-lambdas"></a>Выражения-лямбды ##

 Лямбда-выражение с выражением с правой стороны оператора => называется *выражением-лямбдой*. Выражения-лямбды широко используются при конструировании [деревьев выражений](expression-trees.md). Выражения-лямбды возвращают результат выражения и принимают следующую основную форму.

```csharp
(input parameters) => expression
```

Если лямбда-выражение имеет только один входной параметр, скобки можно не ставить; во всех остальных случаях они обязательны. Нулевое количество входных параметров задается пустыми скобками:

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/expression3.cs#1)]

Два и более входных параметра разделяются запятыми и заключаются в скобки:

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/expression3.cs#2)]

Как правило, компилятор использует определение типа для определения типов параметров. Тем не менее иногда компилятору бывает трудно или даже невозможно определить входные типы. В этом случае типы можно указать в явном виде, как показано в следующем примере.

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/expression3.cs#3)]

Обратите внимание, что тело выражения-лямбды может состоять из вызова метода, как было показано в предыдущем примере. Однако при создании деревьев выражений, которые вычисляются вне .NET Framework, например в SQL Server или Entity Framework (EF), рекомендуется воздержаться от использования вызовов методов в лямбда-выражениях, поскольку методы могут не иметь смысла вне контекста среды выполнения .NET. Если вы решите использовать вызовы методов в этом случае, их необходимо тщательно протестировать, чтобы убедиться, что вызовы методов успешно разрешаются.

## <a name="statement-lambdas"></a>Лямбды операторов ##

Лямбда оператора напоминает выражение-лямбду, за исключением того, что оператор (или операторы) заключается в фигурные скобки:

```csharp
(input parameters) => { statement; }
```

Тело лямбды оператора может состоять из любого количества операторов; однако на практике обычно используется не более двух-трех.

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/statement1.cs#1)]

Лямбды операторов, как и анонимные методы, не могут использоваться для создания деревьев выражений.

## <a name="async-lambdas"></a>Асинхронные лямбда-выражения ##

С помощью ключевых слов [async](language-reference/keywords/async.md) и [await](language-reference/keywords/await.md) можно легко создавать лямбда-выражения и операторы, включающие асинхронную обработку. Например, в примере вызывается метод `ShowSquares`, который выполняется асинхронно.

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/async1.cs#1)]

Дополнительные сведения о создании и использовании асинхронных методов см. в разделе [Асинхронное программирование с использованием ключевых слов Async и Await](programming-guide/concepts/async/index.md).

## <a name="lambda-expressions-and-tuples"></a>Лямбда-выражения и кортежи ##

В C# 7.0 была представлена встроенная поддержка для кортежей. Кортеж можно ввести в качестве аргумента лямбда-выражения, и лямбда-выражение также может возвращать кортеж. В некоторых случаях компилятор C# использует определение типа для определения типов компонентов кортежа. 

Кортеж определяется путем заключения в скобки списка его компонентов с разделителями-запятыми. В следующем примере кортеж с пятью компонентами используется для передачи последовательности чисел в лямбда-выражение, которое удваивает каждое значение и возвращает кортеж с пятью компонентами, содержащий результат операций умножения.

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/tuples1.cs#1)]

Как правило, поля кортежи именуются как `Item1`, `Item2` и т. д. Тем не менее кортеж с именованными компонентами можно определить, как показано в следующем примере:

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/tuples2.cs#1)]

Дополнительные сведения о поддержке кортежей в C# см. в разделе [Типы кортежей C#](tuples.md).

## <a name="lambdas-with-the-standard-query-operators"></a>Лямбда-выражения со стандартными операторами запросов ##

В LINQ to Objects, наряду с другими реализациями, есть входной параметр, тип которого принадлежит к семейству универсальных делегатов @System.Func%601. Эти делегаты используют параметры типа для определения количества и типов входных параметров, а также тип возвращаемого значения делегата. Делегаты `Func` очень полезны для инкапсуляции пользовательских выражений, которые применяются к каждому элементу в наборе исходных данных. Например, рассмотрим делегат @System.Func%601 со следующим синтаксисом:

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#1)]

Экземпляр делегата может быть создан с помощью следующего кода,

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#2)]

где `int` является входным параметром, а `bool` — возвращаемым значением. Возвращаемое значение всегда указывается в последнем параметре типа. Следующий делегат `Func` при вызове возвращает значение true или false, которое показывает, равен ли входной параметр 5:

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#3)]

Лямбда-выражения также можно использовать, когда аргумент имеет тип @System.Linq.Expressions.Expression%601, например в стандартных операторах запросов, которые определены в типе @System.Linq.Queryable. При указании аргумента @System.Linq.Expressions.Expression%601 лямбда-выражение компилируется в дерево выражений. В следующем примере используется стандартный оператор запроса [System.Linq.Enumerable.Count](xref:System.Linq.Enumerable.Count%60%601(System.Collections.Generic.IEnumerable{%60%600})).

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#4)]

Компилятор может вывести тип входного параметра ввода; но его также можно определить явным образом. Данное лямбда-выражение подсчитывает указанные целые значения (`n`), которые при делении на два дают остаток 1.

Следующий пример кода создает последовательность, которая содержит все элементы массива `numbers`, расположенные до 9, поскольку это первое число последовательности, не удовлетворяющее условию.

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#5)]

В следующем примере показано, как указать несколько входных параметров путем их заключения в скобки. Этот метод возвращает все элементы в массиве чисел до того числа, значение которого меньше его порядкового номера в массиве.

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#6)]

## <a name="type-inference-in-lambda-expressions"></a>Определение типа в лямбда-выражениях ##

При написании лямбда-выражений обычно не требуется указывать тип входных параметров, поскольку компилятор может выводить этот тип на основе тела лямбда-выражения, типов параметров и других факторов, как описано в спецификации языка C#. Для большинства стандартных операторов запросов первой входное значение имеет тип элементов в исходной последовательности. При запросе `IEnumerable<Customer>` входная переменная считается объектом `Customer`, а это означает, что у вас есть доступ к его методам и свойствам.

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/infer1.cs#1)]

Общие правила определения типа для лямбда-выражений формулируются следующим образом:

- лямбда-выражение должно содержать то же число параметров, что и тип делегата;

- каждый входной аргумент в лямбда-выражении должен быть неявно преобразуемым в соответствующий параметр делегата;

- возвращаемое значение лямбда-выражения (если таковое имеется) должно быть неявно преобразуемым в возвращаемый тип делегата.

Обратите внимание: лямбда-выражения сами по себе не имеют типа, поскольку в системе общих типов изначально отсутствует понятие "лямбда-выражения". Однако иногда бывает удобно оперировать понятием "типа" применительно к лямбда-выражениям. При этом под типом понимается тип делегата или тип @System.Linq.Expressions.Expression, в который преобразуется лямбда-выражение.

## <a name="variable-scope-in-lambda-expressions"></a>Область действия переменной в лямбда-выражениях ##

Лямбда-выражения могут ссылаться на *внешние переменные* (см. раздел [Анонимные методы](programming-guide/statements-expressions-operators/anonymous-methods.md)), находящиеся в области метода, в котором определена лямбда-функция, или в области типа, который содержит лямбда-выражение. Переменные, полученные таким способом, сохраняются для использования в лямбда-выражениях, даже если бы в ином случае они оказались за границами области действия и уничтожились сборщиком мусора. Внешняя переменная должна быть определенным образом присвоена, прежде чем она сможет использоваться в лямбда-выражениях. В следующем примере демонстрируются эти правила.

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/scope.cs#1)]

 Следующие правила применимы к области действия переменной в лямбда-выражениях.

- Захваченная переменная не будет уничтожена сборщиком мусора до тех пор, пока делегат, который на нее ссылается, не перейдет в статус подлежащего уничтожению при сборке мусора.

- Переменные, вводимые в лямбда-выражении, невидимы во внешнем методе.

- Лямбда-выражение не может непосредственно захватывать параметры `ref` или `out` из метода, в котором они находятся.

- Оператор return в лямбда-выражении не вызывает возвращение значения внешним методом.

- Лямбда-выражение не может содержать оператора `goto` , оператора `break` или оператора `continue` внутри лямбда-функции, если целевой объект перехода находится вне блока. Если целевой объект находится внутри блока, то наличие оператора перехода за пределами лямбда-функции также будет ошибкой.

## <a name="see-also"></a>См. также ##

[Встроенный язык запросов LINQ](../standard/using-linq.md)   
[Анонимные методы](programming-guide/statements-expressions-operators/anonymous-methods.md)   
[Деревья выражений](expression-trees.md)

