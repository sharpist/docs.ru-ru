---
title: Новые возможности в C# 9.0. Руководство по языку C#
description: Обзор новых функций, доступных в C# 9.0.
ms.date: 09/04/2020
ms.openlocfilehash: c165ca764d93b74aac21028ed3e55e80f2a23ee0
ms.sourcegitcommit: 4d45bda8cd9558ea8af4be591e3d5a29360c1ece
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/02/2020
ms.locfileid: "91654911"
---
# <a name="whats-new-in-c-90"></a>Новые возможности C# 9.0

В C# 9.0 добавлены следующие функции и улучшения языка C#.

- [Записи](#record-types)
- [Методы задания только инициализации](#init-only-setters)
- [Инструкции верхнего уровня](#top-level-statements)
- [Улучшения сопоставления шаблонов](#pattern-matching-enhancements)
- Целые числа собственного размера
- Указатели функций
- Отмена создания флага localsinit
- Новые выражения целевого типа
- Статические анонимные функции
- Условное выражение с целевым типом
- Ковариантные возвращаемые типы
- Поддержка расширения `GetEnumerator` для циклов `foreach`
- Параметры удаления лямбда-выражения
- Атрибуты локальных функций
- Инициализаторы модулей
- Новые функции для разделяемых методов

C# 9.0 поддерживается в **.NET 5**. Дополнительные сведения см. в статье [Управление версиями языка C#](../language-reference/configure-language-version.md).

## <a name="record-types"></a>Типы записей

В C# 9.0 появились ***типы записей***, которые представляют собой ссылочный тип, предоставляющий синтезированные методы для обеспечения семантики значений для равенства. По умолчанию записи являются неизменяемыми.

Типы записей упрощают создание неизменяемых ссылочных типов в .NET. Исторически типы .NET в основном классифицируются как ссылочные типы (включая классы и анонимные типы) и типы значений (включая структуры и кортежи). Хотя рекомендуется использовать неизменяемые типы значений, изменяемые типы значений часто не приводят к ошибке. Переменные типа значения содержат значения, поэтому, когда типы значений передаются в методы, изменения вносятся в копию исходных данных.

Также существует множество преимуществ для неизменяемых ссылочных типов. Эти преимущества более выражены в параллельных программах с общими данными. К сожалению, C# вынуждает писать некоторый дополнительный код для создания неизменяемых ссылочных типов. Записи предоставляют объявление типа для неизменяемого ссылочного типа, использующего семантику значения для равенства. Синтезированные методы для проверки на равенство и хэш-кодов считают две записи равными, если равны их свойства. Рассмотрим следующее определение.

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordDefinition":::

Определение записи создает тип `Person`, который содержит два свойства только для чтения: `FirstName` и `LastName`. `Person` является ссылочным типом. Если взглянуть на IL, это будет класс. Он является неизменяемым в том смысле, что ни одно из свойств нельзя изменить после создания. При определении типа записи компилятор синтезирует несколько других методов.

- Методы для определения равенства на основе значений
- Переопределение для <xref:System.Object.GetHashCode>
- Копирование и клонирование членов
- `PrintMembers` и <xref:System.Object.ToString>

Записи поддерживают наследование. Новую запись, производную от `Person`, можно объявить следующим образом.

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="InheritedRecord":::

Можно также запечатывать записи, чтобы предотвратить дальнейшее наследование.

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="SealedRecord":::

Компилятор синтезирует разные версии приведенных выше методов. Сигнатуры методов зависят от того, является ли тип записи запечатанным и является ли прямой базовый класс объектом. Записи должны иметь следующие возможности.

- Проверка равенства основана на значении и включает проверку соответствия типов. Например, `Student` не может быть равно `Person`, даже если две записи имеют одно и то же имя.
- Записи имеют единообразное строковое представление, создаваемое автоматически.
- Записи поддерживают создание копий. Правильная конструкция копирования должна включать иерархии наследования и свойства, добавленные разработчиками.
- Записи можно копировать с изменениями. Операции копирования и изменения поддерживают неразрушающие мутации.

Помимо знакомых перегрузок `Equals`, `operator ==` и `operator !=`, компилятор синтезировал новое свойство `EqualityContract`. Это свойство возвращает объект `Type`, соответствующий типу записи. Если базовый тип равен `object`, свойство будет являться `virtual`. Если базовый тип является другим типом записи, свойство будет являться `override`. Если тип записи равен `sealed`, свойство будет являться `sealed`. Синтезированный метод `GetHashCode` использует `GetHashCode` из всех свойств и полей, объявленных в базовом типе и типе записи. Эти синтезированные методы применяют равенство на основе значений во всей иерархии наследования. Это означает, что `Student` никогда не будет считаться равным `Person` с тем же именем. Типы двух записей должны совпадать, а все свойства, общие для типов записей, равны.

Записи также имеют синтезированный конструктор и метод "clone" для создания копий. Синтезированный конструктор имеет один аргумент типа записи. Он создает новую запись с теми же значениями всех свойств записи. Этот конструктор является закрытым, если запись запечатана, в противном случае он является защищенным. Синтезированный метод "clone" поддерживает конструкцию копирования для иерархий записей. Термин "clone" взят в кавычки, поскольку фактическое имя создается компилятором. Нельзя создать метод с именем `Clone` в типе записи. Синтезированный метод "clone" возвращает тип копируемой записи с помощью виртуальной диспетчеризации. Компилятор добавляет различные модификаторы для метода "clone" в зависимости от модификаторов доступа в `record`.

- Если тип записи является `abstract`, метод "clone" также является `abstract`. Если базовый тип не является `object`, метод также является `override`.
- Для типов записей, которые не являются `abstract`, если базовый тип является `object`
  - Если запись является `sealed`, в метод "clone" не добавляются дополнительные модификаторы (то есть он не `virtual`).
  - Если запись не является `sealed`, метод "clone" является `virtual`.
- Для типов записей, которые не являются `abstract`, если базовый тип не является `object`
  - Если запись является `sealed`, метод "clone" также является `sealed`.
  - Если запись не является `sealed`, метод "clone" является `override`.

В результате всех этих правил сравнение на равенство реализуется единообразно в любой иерархии типов записей. Две записи равны друг другу, если их свойства равны и их типы совпадают, как показано в следующем примере.

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordsEquality":::

Компилятор синтезировал два метода, поддерживающих вывод на печать: переопределение <xref:System.Object.ToString> и `PrintMembers`. `PrintMembers` принимает в качестве аргумента <xref:System.Text.StringBuilder?displayProperty=nameWithType>. Он добавляет разделенный запятыми список имен свойств и значений всех свойств в типе записи. `PrintMembers` вызывает базовую реализацию для всех записей, полученных из других записей. Переопределение <xref:System.Object.ToString> возвращает строку, полученную `PrintMembers`, окруженную символами `{` и `}`. Например, метод <xref:System.Object.ToString> для `Student` возвращает `string`, как показано в следующем коде.

```csharp
"Student { LastName = Wagner, FirstName = Bill, Level = 11 }"
```

В приведенных ранее примерах для объявления свойств использовался традиционный синтаксис. Существует более краткая форма, называемая ***позиционной записью***.  Ниже приведены три типа записей, определенные ранее в виде позиционной записи.

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="PositionalRecords":::

Эти объявления обеспечивают ту же функциональность, что и в предыдущем варианте (с несколькими дополнительными функциями, описанными в следующем разделе). Эти объявления заканчиваются точкой с запятой вместо квадратных скобок, так как эти записи не добавляют дополнительные методы. Можно добавить тело и включить в него дополнительные методы.

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="RecordsWithMethods":::

Для позиционных записей компилятор создает метод `Deconstruct`. Метод `Deconstruct` имеет параметры, соответствующие именам всех общедоступных свойств в типе записи. Метод `Deconstruct` можно использовать для деконструирования записи в свойства ее компонентов.

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="DeconstructRecord":::

Наконец, записи поддерживают ***выражения with***. ***Выражения with*** указывает компилятору создать копию записи, но *с* указанными измененными свойствами.

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="Wither":::

В приведенной выше строке создается новая запись `Person`, в которой свойство `LastName` копируется из `person`, а свойство `FirstName` равно Paul. В выражениях with можно задать любое количество свойств.  Вы можете написать любые синтезируемые члены, за исключением метода "clone". Если тип записи имеет метод, совпадающий с сигнатурой какого-либо синтезируемого метода, компилятор будет его синтезировать. Например, в предыдущем примере записи `Dog` содержится написанный вручную метод <xref:System.String.ToString>.

## <a name="init-only-setters"></a>Методы задания только инициализации

***Методы задания только для инициализации*** обеспечивают единообразный синтаксис для инициализации членов объекта. Инициализаторы свойств позволяют ясно понять, какое значение задает то или иное свойство. Недостаток заключается в том, что эти свойства должны быть устанавливаемыми. Начиная с C# 9.0, для свойств и индексаторов можно создавать методы доступа `init`, а не методы доступа `set`. Вызывающие объекты могут использовать синтаксис инициализатора свойств для установки этих значений в выражениях создания, но после завершения конструирования эти свойства будут доступны только для чтения. Методы задания только для инициализации предоставляют окно для изменения состояния. Это окно закрывается, когда завершается этап конструирования. Этап конструирования фактически завершается после всех инициализаций, включая инициализаторы свойств и выражения with.

Предыдущий пример позиционных записей демонстрирует использование метода задания только для инициализации для задания свойства с помощью выражения with. Можно объявить методы задания только для инициализации в любом написанном вами типе. Ниже приведен пример определения структуры наблюдения за погодой.

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

Вызывающие объекты могут использовать синтаксис инициализатора свойств для установки значений, сохраняя при этом неизменность.

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

Однако изменение наблюдения после инициализации является ошибкой из-за присвоения свойству только для инициализации значения вне инициализации.

```csharp
// Error! CS8852.
now.TemperatureInCelsius = 18;
```

Методы задания только для инициализации могут быть полезны для задания свойств базового класса из производных классов. Они также могут устанавливать производные свойства через вспомогательные методы в базовом классе. В позиционных записях свойства объявляются с помощью методов задания только для инициализации. Эти методы задания используются в выражениях with. Методы задания только для инициализации можно объявить для любых `class` или `struct`, которые вы определяете.

## <a name="top-level-statements"></a>Инструкции верхнего уровня

***Инструкции верхнего уровня*** избавляют от ненужных формальностей во многих приложениях. Рассмотрим каноническую программу Hello World!. .

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

Только одна строка кода что-то делает. С помощью инструкций верхнего уровня можно заменить весь этот шаблон инструкцией `using` и одной строкой, которая делает всю работу.

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

Если требуется однострочная программа, можно удалить директиву `using` и использовать полное имя типа.

```csharp
System.Console.WriteLine("Hello World!");
```

Только один файл в приложении может использовать инструкции верхнего уровня. Если компилятор обнаруживает операторы верхнего уровня в нескольких исходных файлах, это приводит к ошибке. Ошибка также возникает, если объединить операторы верхнего уровня с объявленным методом точки входа программы (как правило, это метод `Main`). В определенном смысле можно сказать, что один файл содержит инструкции, которые обычно находятся в методе `Main` класса `Program`.  

Одним из наиболее распространенных применений этой функции является создание обучающих материалов. Начинающие разработчики C# могут написать каноническую программу Hello World! в одной-двух строках кода. Никакие дополнительные формальности не требуются. Но и опытные разработчики также найдут много применений для этой функции. Инструкции верхнего уровня позволяют экспериментировать в стиле написания сценариев, аналогично записным книжкам Jupyter. Инструкции верхнего уровня отлично подходят для небольших консольных и служебных программ. Функции Azure являются идеальным примером использования операторов верхнего уровня.

Что важнее всего, инструкции верхнего уровня не ограничивают область применения или сложность приложения. Эти инструкции могут обращаться к любому классу .NET и использовать его. Они также не ограничивают использование аргументов командной строки и возвращаемых значений. Инструкции верхнего уровня могут обращаться к массиву строк с именем args. Если инструкции верхнего уровня возвращают целочисленное значение, это значение преобразуется в целочисленный код возврата из синтезированного метода `Main`. Инструкции верхнего уровня могут содержать асинхронные выражения. В этом случае синтезированная точка входа возвращает `Task` или `Task<int>`.

## <a name="pattern-matching-enhancements"></a>Улучшения сопоставления шаблонов

C# 9 включает новые улучшения сопоставления шаблонов.

- ***Шаблоны типов*** проверяют соответствие переменной определенному типу.
- ***Шаблоны в круглых скобках*** усиливают или подчеркивают приоритет сочетаний шаблонов.
- ***В шаблонах конъюнкций `and`*** требуется соответствие обоих шаблонов.
- ***В шаблонах дизъюнкций `or`*** требуется соответствие хотя бы одного из шаблонов.
- ***В шаблонах с отрицанием `not`*** требуется несоответствие шаблона.
- ***В шаблонах сравнения*** требуется, чтобы входные данные были меньше, больше, меньше или равны, больше или равны данной константе.

Эти шаблоны обогащают синтаксис шаблонов. Рассмотрим следующие примеры.

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

Либо с помощью дополнительных скобок можно ясно указать, что `and` имеет более высокий приоритет, чем `or`.

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

Одним из наиболее распространенных применений нового синтаксиса является проверка значения на null.

```csharp
if (e is not null)
{
    // ...
}
```

Любой из этих шаблонов можно использовать в любом контексте, где разрешены шаблоны: выражения с шаблоном `is`, выражения `switch`, вложенные шаблоны и шаблоны метки `case` оператора `switch`.

## <a name="performance-and-interop"></a>Производительность и взаимодействие

Три новых функции улучшают поддержку взаимодействия на уровне неуправляемого кода и низкоуровневых библиотек, требующих высокой производительности: целые числа собственного размера, указатели функций и пропуск флага `localsinit`.

Целые числа собственного размера `nint` и `nuint` являются целочисленными типами. Они выражаются базовыми типами <xref:System.IntPtr?displayProperty=nameWithType> и <xref:System.UIntPtr?displayProperty=nameWithType>. Компилятор предоставляет дополнительные преобразования и операции для этих типов в качестве собственных целых чисел. Целые числа собственного размера определяют свойства для `MaxValue` или `MinValue`. Такие значения не могут быть выражены как константы времени компиляции, так как они зависят от собственного размера целого числа на целевом компьютере. Во время выполнения эти значения доступны только для чтения. Для `nint` можно использовать значения констант в диапазоне [`int.MinValue` .. `int.MaxValue`]. Для `nuint` можно использовать значения констант в диапазоне [`uint.MinValue` .. `uint.MaxValue`]. Компилятор выполняет сворачивание константы для всех унарных и бинарных операторов, используя типы <xref:System.Int32?displayProperty=nameWithType> и <xref:System.UInt32?displayProperty=nameWithType>. Если результат не помещается в 32 бит, операция выполняется во время выполнения и не считается константой. Целые числа собственного размера могут повысить производительность в сценариях с большим количеством целочисленных вычислений, в которых необходимо обеспечить максимально высокую производительность.

Указатели функций предоставляют простой синтаксис для доступа к кодам операций IL `ldftn` и `calli`. Указатели функций можно объявлять с помощью нового синтаксиса `delegate*`. Тип `delegate*` — это тип указателя. При вызове типа `delegate*` используется `calli`, в отличие от делегата, который использует `callvirt` в методе `Invoke()`. Синтаксически вызовы являются идентичными. При вызове указателя функции используется соглашение о вызовах `managed`. Если требуется объявить о соглашении о вызовах `unmanaged`, добавьте ключевое слово `unmanaged` после синтаксиса `delegate*`. Другие соглашения о вызовах можно указать с помощью атрибутов в объявлении `delegate*`.

Наконец, можно добавить атрибут <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType>, чтобы компилятор не создавал флаг `localsinit`. Этот флаг указывает среде CLR на нулевую инициализацию всех локальных переменных. Флаг `localsinit` используется в C# по умолчанию, начиная с версии 1.0. Однако при использовании дополнительной нулевой инициализации в некоторых сценариях может снизиться производительность. В частности, при использовании `stackalloc`. В таких случаях можно добавить атрибут <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>. Его можно добавить в один метод или свойство, в `class`, `struct`, `interface` или даже в модуль. Этот атрибут не влияет на методы `abstract`. Он влияет на код, созданный для реализации.

Эти функции могут повысить производительность в некоторых сценариях. Их следует использовать только после тщательного тестирования как до, так и после внедрения. Код, включающий целые числа собственного размера, нужно тестировать на нескольких целевых платформах с различными размерами целых чисел. Другие функции требуют небезопасный код.

## <a name="fit-and-finish-features"></a>Функции подбора и завершения

Многие другие функции позволяют более эффективно писать код. В C# 9.0 можно опустить тип в [выражении `new`](../language-reference/operators/new-operator.md), если тип созданного объекта уже известен. Наиболее часто это используется в объявлениях полей.

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

`new` с целевым типом можно также использовать, если необходимо создать объект для передачи его в качестве аргумента в метод. Рассмотрим метод `ForecastFor()` со следующей сигнатурой.

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

Его можно вызвать следующим образом.

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

Еще один полезный способ использовать эту функцию — объединить ее со свойствами только для инициализации при инициализации нового объекта.

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

Экземпляр, созданный конструктором по умолчанию, можно вернуть с помощью инструкции `return new();`.

Аналогичная функция улучшает разрешение целевого типа в [условных выражениях](../language-reference/operators/conditional-operator.md). Благодаря такому изменению два выражения необязательно должны иметь неявное преобразование из одного в другое, но оба могут иметь неявные преобразования в целевой тип. Скорее всего, вы не заметите этого изменения. Обратите внимание, что некоторые условные выражения, которые ранее требовали приведения или не компилировались, теперь просто начнут работать.

Начиная с C# 9.0, можно добавлять модификатор `static` в [лямбда-выражения](../language-reference/operators/lambda-expressions.md) или [анонимные методы](../language-reference/operators/delegate-operator.md). Статические лямбда-выражения аналогичны локальным функциям с модификатором `static`: статические лямбда-выражения и анонимные методы не могут захватывать локальные переменные и состояние экземпляра. Модификатор `static` предотвращает случайное захватывание других переменных.

Ковариантные возвращаемые типы обеспечивают гибкость для возвращаемых типов переопределенных функций. Переопределяемая виртуальная функция может возвращать тип, производный от типа возвращаемого значения, объявленного в методе базового класса. Это может быть полезно для записей и для других типов, которые поддерживают виртуальные методы клонирования или фабричные методы.

Кроме того, [цикл `foreach`](../language-reference/keywords/foreach-in.md) будет распознавать и использовать метод расширения `GetEnumerator`, который в противном случае удовлетворяет шаблону `foreach`. Это изменение означает, что `foreach` согласуется с другими конструкциями на основе шаблонов, такими как асинхронная модель и деконструирование на основе шаблона. На практике это изменение означает, что можно добавить поддержку `foreach` в любой тип. При перечислении объектов имеет смысл ограничить его использование.

Кроме того, можно использовать пустые переменные в качестве параметров для лямбда-выражений. Это удобное изменение позволяет избежать присвоения имени аргументу, а компилятор может избежать его использования. Для любого аргумента используется символ `_`. Дополнительные сведения см. в разделе [Входные параметры лямбда-выражения](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) статьи о [лямбда-выражениях](../language-reference/operators/lambda-expressions.md).

Наконец, теперь можно применять атрибуты к локальным функциям. Например, к локальным функциям можно применить заметки атрибутов, допускающих значение null.

## <a name="support-for-code-generators"></a>Поддержка генераторов кода

Две заключительные функции обеспечивают поддержку генераторов кода в C#. Генераторы кода C# — это компонент, который вы можете написать подобно анализатору или исправлению кода Roslyn. Разница заключается в том, что генераторы кода анализируют код и пишут новые файлы исходного кода в рамках процесса компиляции. Типичный генератор кода ищет в коде атрибуты или другие соглашения.

Генератор кода считывает атрибуты или другие элементы кода с помощью анализирующих API-интерфейсов Roslyn. На основе этой информации он добавляет новый код в компиляцию. Генераторы исходного кода могут только добавлять код, они не могут изменять существующий код в компиляции.

Этими двумя функциями, добавленными для поддержки генераторов кода, являются расширения для ***синтаксиса разделяемого метода*** и ***инициализаторов модулей***. Сначала рассмотрим изменения в разделяемые методы. До C# 9.0 разделяемые методы были `private`, но не могли иметь модификаторов доступа, иметь возвращаемое значение `void` и параметры `out`. Эти ограничения подразумевают, что, если реализация метода не предоставлена, компилятор удаляет все вызовы к разделяемому методу. В C# 9.0 эти ограничения снимаются, но требуется, чтобы объявления разделяемых методов имели реализацию. Генераторы кода могут предоставить такую реализацию. Чтобы избежать критических изменений, компилятор рассматривает любой разделяемый метод без модификатора доступа как метод, следующий старым правилам. Если разделяемый метод включает модификатор доступа `private`, этот разделяемый метод обрабатывается в соответствии с новыми правилами.

Второй новой функцией для генераторов кода являются ***инициализаторы модулей***. Инициализаторы модулей — это методы, к которым прикреплен атрибут <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute>. Эти методы вызываются средой выполнения при загрузке сборки. Метод инициализатора модуля:

- должен быть статическим;
- должен быть без параметров;
- должен возвращать значение void;
- не должен быть универсальным методом;
- не должен содержаться в универсальном классе;
- должен быть доступен из содержащего модуля.

Последний пункт фактически означает, что метод и содержащий его класс должны быть внутренними или открытыми. Метод не может быть локальной функцией.
